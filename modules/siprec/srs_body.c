/*
 * Copyright (C) 2017 OpenSIPS Project
 *
 * This file is part of opensips, a free SIP server.
 *
 * opensips is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * opensips is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 *
 * History:
 * ---------
 *  2017-06-20  created (razvanc)
 */

#include <string.h>
#include "srs_body.h"
#include "src_sess.h"
#include "../../parser/sdp/sdp.h"
#include "../../mem/shm_mem.h"
#include "../../msg_translator.h"
#include "../../ut.h"
#include "../../trim.h"

struct rtpproxy_binds srec_rtp;

/* TODO handle port */
static int port = 10000;

int srs_init_sdp_body(struct srs_sdp *body)
{
	memset(body, 0, sizeof *body);
	INIT_LIST_HEAD(&body->streams);
	
	body->ts = time(NULL);

	return 0;
}

struct srs_sdp_stream *srs_get_stream(struct srs_sdp *body, int label)
{
	struct list_head *it;
	struct srs_sdp_stream *stream;

	list_for_each(it, &body->streams) {
		stream = list_entry(it, struct srs_sdp_stream, list);
		if (stream->label == label)
			return stream;
	}
	return NULL;
}

void srs_free_stream(struct srs_sdp_stream *stream)
{
	shm_free(stream);
}

void srs_free_body(struct srs_sdp *body)
{
	struct list_head *it, *tmp;
	list_for_each_safe(it, tmp, &body->streams)
		srs_free_stream(list_entry(it, struct srs_sdp_stream, list));
}

/*
 * return the first character in the line if found,
 * and the entire line in line parameter
 */
static char srs_get_sdp_line(char *start, char *end, str *line)
{
	char *p = start;

	/* eat the spaces at the beginning */
	while (p < end && is_ws(*p))
		p++;
	/* nothing here */
	if (p == end)
		return 0;
	line->s = p;
	/* search for \r or \n */
	while (p < end && *p != '\r' && *p != '\n')
		p++;
	while (p < end && is_ws(*p))
		p++;
	line->len = p - line->s;
	if (line->len)
		return *line->s;
	else
		return 0;
}

int srs_add_sdp_streams(struct sip_msg *msg, struct srs_sdp *sdp, int caller)
{
	char sdp_type;
	char *tmps;
	char *allocated_buf;
	int label_len, media_inactive, tmp_len;
	sdp_info_t *msg_sdp;
	sdp_session_cell_t *msg_session;
	sdp_stream_cell_t *msg_stream;
	str tmp_buf, globals_buf, media_buf, line;
	char *start, *end;
	int streams_no = 0;
	int medianum = 0;

	struct srs_sdp_stream *stream = NULL;

	msg_sdp = parse_sdp(msg);
	if (!msg_sdp)
		return 0;
	allocated_buf = NULL;
	/*
	 * we are only interested by streams, because everything else will be
	 * generated by us
	 */
	for (msg_session = msg_sdp->sessions; msg_session;
			msg_session = msg_session->next) {
		/* we first compute the global lines */

		/*
		 * we need to parse it line by line, because the parser does not
		 * support that; we allocate the whole body in sdp and adjust in shm
		 */
		allocated_buf = pkg_malloc(msg_session->body.len);
		if (!allocated_buf) {
			LM_ERR("no more pkg memory to build body stream!\n");
			return -1;
		}
		tmp_buf.s = allocated_buf;
		tmp_buf.len = 0;

		start = msg_session->body.s;
		end = start + msg_session->body.len;

		while ((sdp_type = srs_get_sdp_line(start, end, &line)) != 0) {
			/* globals are just until they reach m= line */
			if (sdp_type == 'm')
				break;
			/* TODO: we need separate buffers for each type, because they need
			 * to be all in order when we put them in the session */
			else if (sdp_type == 'b' ||sdp_type == 'z' || sdp_type == 'k' || sdp_type == 'a') {
				memcpy(tmp_buf.s + tmp_buf.len, line.s, line.len);
				tmp_buf.len += line.len;
			}
			start += line.len;
		}
		globals_buf = tmp_buf;

		for (msg_stream = msg_session->streams; msg_stream;
				msg_stream = msg_stream->next) {

			/* if it is not RTP, we are not interested */
			if (!msg_stream->is_rtp)
				continue;

			/* use the rest of the buffer here */
			tmp_buf.s += globals_buf.len;
			tmp_buf.len = 0;
			media_buf.s = 0;
			media_buf.len = 0;

			start = msg_stream->body.s;
			end = start + msg_stream->body.len;

			media_inactive = msg_stream->is_on_hold ? 1: 0;

			while ((sdp_type = srs_get_sdp_line(start, end, &line)) != 0) {
				switch (sdp_type) {
				case 'm':
					/*
					 * the m line needs to be copied almost idetically, except
					 * the port needs to be altered to make sure it does not
					 * overlap
					 */
					media_buf = tmp_buf;

					/* media */
					memcpy(media_buf.s, line.s, msg_stream->port.s - line.s);
					media_buf.len += msg_stream->port.s - line.s;

					/* port */
					tmps = int2str(port++, &tmp_len);
					memcpy(media_buf.s + media_buf.len, tmps, tmp_len);
					media_buf.len += tmp_len;
					media_buf.s[media_buf.len++] = ' ';

					/* the rest of the transport */
					tmp_len = line.len - (msg_stream->transport.s - line.s);
					memcpy(media_buf.s + media_buf.len, msg_stream->transport.s, tmp_len);
					media_buf.len += tmp_len;

					/* adjust the tmp_buf */
					tmp_buf.s += media_buf.len;
					tmp_buf.len = 0;
					break;

				case 'a':
					/* we skip a=send/recv/only and a=label attributes
					 * because they will be added later by us */
					if (line.len > 8 /* a=label: */ &&
							memcmp(line.s + 2, "label:", 6) == 0)
						break;
					else if (line.len > 2 /* a= */ + 8 + 1/* \r */ &&
							(line.s[10] == '\r' || line.s[10] == '\n')) {
						if (memcmp(line.s + 2, "sendrecv", 8) == 0 ||
								memcmp(line.s + 2, "sendonly", 8) == 0)
							break;
						if (memcmp(line.s + 2, "recvonly", 8) == 0 ||
								memcmp(line.s + 2, "inactive", 8) == 0) {
							media_inactive = 1;
							break;
						}
						LM_INFO("check passed for [%.*s]\n", 8, line.s + 2);
					}
				case 'b':
				case 'k':
					memcpy(tmp_buf.s + tmp_buf.len, line.s, line.len);
					tmp_buf.len += line.len;
					break;
				}
				start += line.len;
			}
			/* compute the extra length of the stream */
			tmp_len = 12/* a=inactive\r\n or a=sendonly\r\n */;
			tmps = int2str(sdp->stream_no + 1, &label_len);
			tmp_len += 8 /* a=label: */ + label_len + 2 /* \r\n */;

			/* create a new stream to dump all data into */
			stream = shm_malloc(sizeof *stream +
					globals_buf.len + media_buf.len + tmp_buf.len + tmp_len);
			if (!stream) {
				LM_ERR("cannot alloc new stream!\n");
				pkg_free(allocated_buf);
				return -1;
			}
			memset(stream, 0, sizeof *stream);

			stream->body.s = (char *)stream + (sizeof *stream);
			stream->caller = caller;
			stream->medianum = ++medianum;

			/* m line */
			memcpy(stream->body.s, media_buf.s, media_buf.len);
			stream->body.len = media_buf.len;

			memcpy(stream->body.s + stream->body.len, globals_buf.s, globals_buf.len);
			stream->body.len += globals_buf.len;

			memcpy(stream->body.s + stream->body.len, tmp_buf.s, tmp_buf.len);
			stream->body.len += tmp_buf.len;

			/* a=label line */
			memcpy(stream->body.s + stream->body.len, "a=label:", 8);
			stream->body.len += 8;
			memcpy(stream->body.s + stream->body.len, tmps, label_len);
			stream->body.len += label_len;
			memcpy(stream->body.s + stream->body.len, "\r\na=", 4);
			stream->body.len += 4;

			/* sendonly or inactive */
			if (media_inactive)
				memcpy(stream->body.s + stream->body.len, "inactive\r\n", 10);
			else
				memcpy(stream->body.s + stream->body.len, "sendonly\r\n", 10);
			stream->body.len += 10;

			/* all good, add it into the sdp */
			stream->label = ++sdp->stream_no;
			list_add_tail(&stream->list, &sdp->streams);
			streams_no++;
		}
		pkg_free(allocated_buf);
	}
	return streams_no;
}

#define OSS_BOUNDARY_HDR CRLF "--" OSS_BOUNDARY CRLF
#define OSS_BOUNDARY_HDR_LEN (sizeof(OSS_BOUNDARY_HDR) - 1)
#define OSS_BOUNDARY_HDR_END CRLF "--" OSS_BOUNDARY "--" CRLF
#define OSS_BOUNDARY_HDR_END_LEN (sizeof(OSS_BOUNDARY_HDR_END) - 1)

#define OSS_CT_HDR "Content-Type: "
#define OSS_CT_HDR_LEN (sizeof(OSS_CT_HDR) - 1)

#define OSS_CT_SDP_HDR OSS_CT_HDR "application/sdp" CRLF
#define OSS_CT_SDP_HDR_LEN (sizeof(OSS_CT_SDP_HDR) - 1)

#define OSS_CT_SREC_HDR OSS_CT_HDR "application/rs-metadata+xml" CRLF
#define OSS_CT_SREC_HDR_LEN (sizeof(OSS_CT_SREC_HDR) - 1)

#define OSS_CD_SREC_HDR "Content-Disposition: recording-session" CRLF
#define OSS_CD_SREC_HDR_LEN (sizeof(OSS_CD_SREC_HDR) - 1)

/*
 * You need to free the body->s after using it!
 */
int srs_get_body(struct src_sess *sess, struct srs_sdp *sdp, str *body)
{
	struct srs_sdp_stream *stream;
	struct list_head *it;
	int multipart;
	str id = str_init(""), version = str_init("");
	void *siprec = (void *)0x1 /* TODO: replace with real siprec */;

	/* body may be a multipart consisting on a SDP and a SIPREC XML */
	int body_len = 0;

	multipart = sdp && siprec;
	if (multipart) {
		/* multipart overhead */
		body_len += OSS_BOUNDARY_HDR_LEN * 2 + OSS_BOUNDARY_HDR_END_LEN;
		body_len -= CRLF_LEN /* XXX: we do not add the first CRLF */;
		/* SDP */
		body_len += OSS_CT_SDP_HDR_LEN + CRLF_LEN;
		/* SIPREC */
		body_len += OSS_CT_SREC_HDR_LEN + OSS_CD_SREC_HDR_LEN +  CRLF_LEN;
	}

	if (sdp) {
		/*
		 * SDP body format we use:
		 *
		 * v=0
		 * o=- <timestamp> <version> IN IP4 <mediaip>
		 * s=-
		 */
		id.s = int2str(sdp->ts, &id.len);
		version.s = int2str(sdp->version, &version.len);
		body_len += id.len + version.len + sess->media_ip.len +
			19 + 3 * CRLF_LEN /* 3 lines */;

		list_for_each(it, &sdp->streams) {
			stream = list_entry(it, struct srs_sdp_stream, list);
			body_len += stream->body.len;
		}
	}

	if (siprec) {
		/* TODO: add body size for siprec */
	}

	body->s = pkg_malloc(body_len);
	if (!body->s) {
		LM_ERR("no more memory for message body %d\n", body_len);
		return -1;
	}
	body->len = 0;

	if (multipart) {
		/* first boundary */
		/* we do not add the first CRLF, because the message generator already
		 * adds it */
		memcpy(body->s + body->len, OSS_BOUNDARY_HDR + CRLF_LEN, OSS_BOUNDARY_HDR_LEN - CRLF_LEN);
		body->len += OSS_BOUNDARY_HDR_LEN - CRLF_LEN;

		/* Content-Type of SDP */
		memcpy(body->s + body->len, OSS_CT_SDP_HDR, OSS_CT_SDP_HDR_LEN);
		body->len += OSS_CT_SDP_HDR_LEN;
		memcpy(body->s + body->len, CRLF, CRLF_LEN);
		body->len += CRLF_LEN;
	}

	if (sdp) {
		/* SDP body */
		memcpy(body->s + body->len, "v=0" CRLF "o=- ", 7 + CRLF_LEN);
		body->len += 7 + CRLF_LEN;
		memcpy(body->s + body->len, id.s, id.len);
		body->len += id.len;
		body->s[body->len++] = ' ';
		memcpy(body->s + body->len, version.s, version.len);
		body->len += version.len;
		memcpy(body->s + body->len, " IN IP4 ", 8);
		body->len += 8;
		memcpy(body->s + body->len, sess->media_ip.s, sess->media_ip.len);
		body->len += sess->media_ip.len;
		memcpy(body->s + body->len, CRLF "s=-" CRLF , 3 + 2 * CRLF_LEN);
		body->len += 3 + 2 * CRLF_LEN;

		list_for_each(it, &sdp->streams) {
			stream = list_entry(it, struct srs_sdp_stream, list);
			memcpy(body->s + body->len, stream->body.s, stream->body.len);
			body->len += stream->body.len;
		}
	}

	if (multipart) {
		/* add second bondary */
		memcpy(body->s + body->len, OSS_BOUNDARY_HDR, OSS_BOUNDARY_HDR_LEN);
		body->len += OSS_BOUNDARY_HDR_LEN;

		/* Content-Type of SIPREC */
		memcpy(body->s + body->len, OSS_CT_SREC_HDR, OSS_CT_SREC_HDR_LEN);
		body->len += OSS_CT_SREC_HDR_LEN;

		/* Content-Disposition for SIPREC */
		memcpy(body->s + body->len, OSS_CD_SREC_HDR, OSS_CD_SREC_HDR_LEN);
		body->len += OSS_CD_SREC_HDR_LEN;

		memcpy(body->s + body->len, CRLF, CRLF_LEN);
		body->len += CRLF_LEN;
	}
	
	if (siprec) {
		/* TODO: add siprec body */
	}

	if (multipart) {
		/* add final boundary */
		memcpy(body->s + body->len, OSS_BOUNDARY_HDR_END, OSS_BOUNDARY_HDR_END_LEN);
		body->len += OSS_BOUNDARY_HDR_END_LEN;
	}

	/* double check length */
	if (body->len != body_len) {
		LM_BUG("mismatch in body build computed=%d generated=%d [%.*s]\n",
				body_len, body->len, body->len, body->s);
		pkg_free(body->s);
		return -2;
	}
	return 0;
}

int srs_handle_media(struct sip_msg *msg, struct src_sess *sess)
{
	int len;
	int label;
	int streams_no = -1;
	struct srs_sdp_stream *stream;
	sdp_info_t *msg_sdp;
	sdp_attr_t *attr;
	sdp_stream_cell_t *msg_stream;
	sdp_session_cell_t *msg_session;
	str destination;
	str *from_tag, *to_tag;

	msg_sdp = parse_sdp(msg);
	if (!msg_sdp) {
		LM_ERR("mising or invalid SDP!\n");
		return -1;
	}

	for (msg_session = msg_sdp->sessions; msg_session;
			msg_session = msg_session->next) {
		for (msg_stream = msg_session->streams; msg_stream;
				msg_stream = msg_stream->next) {
			/* first get the label, to know which stream we are talking about */
			label = -1;
			for (attr = msg_stream->attr; attr && label == -1; attr = attr->next) {
				if (attr->value.len != 0 && attr->attribute.len == 5 &&
					memcmp(attr->attribute.s, "label", 5) == 0) {
					if (str2sint(&attr->value, &label) < 0) {
						LM_ERR("invalid label number: %.*s - should have been numeric\n",
								attr->value.len, attr->value.s);
						continue;
					}
					stream = srs_get_stream(&sess->sdp, label);
					if (!stream) {
						LM_ERR("unknown media stream label: %d\n", label);
						label = -2;
					}
					break;
				}
			}
			if (label < 0) {
				LM_ERR("SDP stream not processed for [%.*s]\n",
						msg_stream->body.len, msg_stream->body.s);
				continue;
			}
			LM_DBG("found stream %p for label %d\n", stream, label);

			len = 4/* udp: */;
			/* if there is an IP in the stream, use it, otherwise use the
			 * SDP session IP */
			if (msg_stream->ip_addr.len)
				len += msg_stream->ip_addr.len;
			else
				len += msg_session->ip_addr.len;
			len += 1/* : */ + msg_stream->port.len;

			/* build the socket to stream to */
			destination.s = pkg_malloc(len);
			if (!destination.s) {
				LM_ERR("cannot allocate destination buffer!\n");
				return -1;
			}
			memcpy(destination.s, "udp:", 4);
			destination.len = 4;
			if (msg_stream->ip_addr.len) {
				memcpy(destination.s + destination.len, msg_stream->ip_addr.s,
						msg_stream->ip_addr.len);
				destination.len += msg_stream->ip_addr.len;
			} else {
				memcpy(destination.s + destination.len, msg_session->ip_addr.s,
						msg_session->ip_addr.len);
				destination.len += msg_session->ip_addr.len;
			}
			destination.s[destination.len++] = ':';
			memcpy(destination.s + destination.len, msg_stream->port.s,
					msg_stream->port.len);
			destination.len += msg_stream->port.len;

			if (stream->caller) {
				from_tag = &sess->dlg->legs[DLG_CALLER_LEG].tag;
				to_tag = &sess->dlg->legs[callee_idx(sess->dlg)].tag;
			} else {
				from_tag = &sess->dlg->legs[callee_idx(sess->dlg)].tag;
				to_tag = &sess->dlg->legs[DLG_CALLER_LEG].tag;
			}

			if (srec_rtp.start_recording(&sess->dlg->callid, from_tag, to_tag,
					NULL/* TODO: set */, NULL, &destination, stream->medianum) < 0) {
				LM_ERR("cannot start recording for stream %p (label=%d)\n",
						stream, stream->label);
			} else
				streams_no++;

			pkg_free(destination.s);
		}
	}

	return streams_no;
}
